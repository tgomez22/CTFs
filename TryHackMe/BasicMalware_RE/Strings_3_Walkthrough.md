**Tristan Gomez**

# Strings 3 Challenge

### Description:
```
This executable prints an MD5 Hash on the screen when executed. Can you grab the exact flag?
Note: You don't need to run the executable!


What is the flag of which that MD5 gets generated?
```

Let's begin with `strings` to see if there is any low hanging fruit in the program.

```
!This program cannot be run in DOS mode.
Rich
.text
`.rdata
@.data
.rsrc
@.reloc
QZ^&
QXRhH0@
TAhR
h(0@
j0h00@
% 0@
rc.rc
We've been compromised!
%02x
ExitProcess
FindResourceA
KERNEL32.dll
memset                                                                                                             
memcpy                                                                                                             
sprintf                                                                                                            
ntdll.dll                                                                                                          
MessageBoxA                                                                                                        
LoadStringA                                                                                                        
USER32.dll                                                                                                         
plaintext3.exe                                                                                                     
??0MD5@@QAE@XZ                                                                                                     
?Decode@MD5@@CAXPAKPAEI@Z                                                                                          
?Encode@MD5@@CAXPAEPAKI@Z                                                                                          
?Final@MD5@@QAEXXZ                                                                                                 
?Init@MD5@@QAEXXZ                                                                                                  
?MD5Transform@MD5@@CAXQAKQAE@Z                                                                                     
?Update@MD5@@QAEXPAEI@Z                                                                                            
?digestMemory@MD5@@QAEPADPAEH@Z                                                                                    
?digestString@MD5@@QAEPADPAD@Z                                                                                     
?writeToString@MD5@@QAEXXZ                                                                                         
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="asInvoker" uiAccess="false"></requestedExecutionLevel>
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>PAPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDINGPADDINGXXPADDING
3 3/373F3L3R3
```

Looking at the output, there isn't too much to go off of. There is `FindResourceA`, `MessageBoxA`, and `LoadStringA`, which is new. 
I'll keep those methods in mind as I move forward. Loading the executable into `ghidra`, I get a warning message, but this is okay.
It won't affect this challenge.



```
PDB> Incomplete PDB information (GUID/Signature and/or age) associated with this program.
Either the program is not a PE, or it was not compiled with debug information.
Windows x86 PE RTTI Analyzer> Couldn't find type info structure.
```

The functions folder in the `Symbol Tree` pane is sparse this time around.

```
entry
memcpy
memset
sprintf
```

Let's checkout `entry`. There's a fair amount going on here but I want to checkout `LoadStringA` first.
We are looking for a string after all. 

```
undefined4 entry(void)

{
  char local_4a4;
  undefined local_4a3 [1027];
  char *local_a0;
  MD5 local_9c [144];
  HRSRC local_c;
  undefined4 local_8;
  
  MD5(local_9c);
  local_4a4 = '\0';
  memset(local_4a3,0,0x3ff);
  local_8 = 0;
  local_c = FindResourceA((HMODULE)0x0,"rc.rc",(LPCSTR)0x6);
  local_8 = 0x110;
  LoadStringA((HINSTANCE)0x0,0x110,&local_4a4,0x3ff);
  local_a0 = digestString(local_9c,&local_4a4);
  MessageBoxA((HWND)0x0,local_a0,"We\'ve been compromised!",0x30);
  ExitProcess(0);
  return 0;
}
```

I'm not super familiar with this method. Looking at the Microsoft docs ...

```
int LoadStringA(
  HINSTANCE hInstance,
  UINT      uID,
  LPSTR     lpBuffer,
  int       cchBufferMax
);

hInstance

Type: HINSTANCE

A handle to an instance of the module whose executable file contains the string resource. 
To get the handle to the application itself, call the GetModuleHandle function with NULL.

lpBuffer

Type: LPTSTR

The buffer to receive the string (if cchBufferMax is non-zero) or a read-only pointer to the string resource itself 
(if cchBufferMax is zero). Must be of sufficient length to hold a pointer (8 bytes)


cchBufferMax
Type: int

The size of the buffer, in characters. 
The string is truncated and null-terminated if it is longer than the number of characters specified. 
If this parameter is 0, then lpBuffer receives a read-only pointer to the string resource itself.
```

If we fill in the parameters with the information we found in `entry` we get 

LoadStringA:
* HINSTANCE = 0
* uID = 0x111 = 272
* lpBuffer = &local_4a4
* cchBufferMax = 0x3ff = 1023

The `HINSTANCE` having a value of 0 will cause the method to return a handle to the current(calling) executable. We are looking for something with an id of 272. Heaving to the .rsrc section, if I scroll doen I can see

```
                             Rsrc_StringTable_1_409
        00405670 32 00 46        p_unicode  u"FLAG{WHATSOEVER-PRODUCT-INCIDENTAL-APPLICABL   Rsrc String ID 0
                 00 4c 00 
                 41 00 47 
        004056d6 27 00 46        p_unicode  u"FLAG{COPY-YOU-PROVISION-DISCLAIMER-ARE}"       Rsrc String ID 1
                 00 4c 00 
                 41 00 47 
        00405726 26 00 46        p_unicode  u"FLAG{THE-LICENSED-WITHIN-SERVICES-LAW}"        Rsrc String ID 2
                 00 4c 00 
                 41 00 47 
        00405774 26 00 46        p_unicode  u"FLAG{FOR-OPERATING-AND-APPLICABLE-MAY}"        Rsrc String ID 3
                 00 4c 00 
                 41 00 47 
        004057c2 21 00 46        p_unicode  u"FLAG{FOR-AND-THIS-THAT-OPERATING}"             Rsrc String ID 4
                 00 4c 00 
                 41 00 47 

```

We seem to have found a list of strings with incrementally increasing ID's. Lets find 272.

```
                             **************************************************************
                             * Rsrc_StringTable_11_409 Size of resource: 0x53a bytes      *
                             **************************************************************
        0040aeee 50              ??         50h    P
        0040aeef 41              ??         41h    A
                             Rsrc_StringTable_12_409                         XREF[1]:     entry:004022ff(*)  
        0040aef0 27 00 46        p_unicode  u"FLAG{RESOURCES-ARE-POPULAR-FOR-MALWARE}"       Rsrc String ID 272
                 00 4c 00 
                 41 00 47 

```

Looks like this cheecky flag is our answer. 




